
name: Generic.Forensic.SQLiteHunter
description: |
    Hunt for SQLite files.
    
    SQLite has become the de-facto standard for storing application data,
    in many types of applications:
    
    - Web Browsers
    - Operating Systems
    - Various applications, such as iMessage, TCC etc
    
    This artifact can hunt for these artifacts in a mostly automated way.
    More info at https://github.com/Velocidex/SQLiteHunter
    
    NOTE: If you want to use this artifact on just a bunch of files already
    collected (for example the files collected using the
    Windows.KapeFiles.Targets artifact) you can use the CustomGlob parameter
    (for example set it to "/tmp/unpacked/**" to consider all files in the
    unpacked directory).
    
    

column_types:
- name: Image
  type: preview_upload

export: |
  LET SPEC <= "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"
  LET Specs <= parse_json(data=gunzip(string=base64decode(string=SPEC)))
  LET CheckHeader(OSPath) = read_file(filename=OSPath, length=12) = "SQLite forma"
  LET Bool(Value) = if(condition=Value, then="Yes", else="No")

  -- In fast mode we check the filename, then the header then run the sqlite precondition
  LET matchFilename(SourceName, OSPath) = OSPath =~ get(item=Specs.sources, field=SourceName).filename
    AND CheckHeader(OSPath=OSPath)
    AND Identify(SourceName= SourceName, OSPath= OSPath)
    AND log(message=format(format="%v matched by filename %v",
            args=[OSPath, get(item=Specs.sources, field=SourceName).filename]))

  -- If the user wanted to also upload the file, do so now
  LET MaybeUpload(OSPath) = if(condition=AlsoUpload, then=upload(file=OSPath)) OR TRUE

  LET Identify(SourceName, OSPath) = SELECT if(
    condition=CheckHeader(OSPath=OSPath),
    then={
      SELECT *
      FROM sqlite(file=OSPath, query=get(item=Specs.sources, field=SourceName).id_query)
    }) AS Hits
  FROM scope()
  WHERE if(condition=Hits[0].Check = get(item=Specs.sources, field=SourceName).id_value,
    then= log(message="%v was identified as %v",
            args=[OSPath, get(item=Specs.sources, field=SourceName).Name]),
    else=log(message="%v was not identified as %v (got %v, wanted %v)",
             args=[OSPath, get(item=Specs.sources, field=SourceName).Name, str(str=Hits),
                   get(item=Specs.sources, field=SourceName).id_value]) AND FALSE)

  LET ApplyFile(SourceName) = SELECT * FROM foreach(row={
     SELECT OSPath FROM AllFiles
     WHERE if(condition=MatchFilename,  then=matchFilename(SourceName=SourceName, OSPath=OSPath),
      else=Identify(SourceName= SourceName, OSPath= OSPath))

  }, query={
     SELECT *, OSPath FROM sqlite(
        file=OSPath, query=get(item=Specs.sources, field=SourceName).SQL)
  })

  -- Filter for matching files without sqlite checks.
  LET FilterFile(SourceName) =
     SELECT OSPath FROM AllFiles
     WHERE if(condition=MatchFilename,
              then=OSPath =~ get(item=Specs.sources, field=SourceName).filename)

  -- Build a regex for all enabled categories.
  LET all_categories = SELECT _value FROM foreach(row=["All","MacOS","Chrome","Browser","Edge","Firefox","InternetExplorer","Windows"]) WHERE get(field=_value)
  LET category_regex <= join(sep="|", array=all_categories._value)
  LET AllGlobs <= filter(list=Specs.globs, condition="x=> x.tags =~ category_regex")
  LET _ <= log(message="Globs for category %v is %v", args=[category_regex, CustomGlob || AllGlobs.glob])
  LET AllFiles <= SELECT OSPath FROM glob(globs=CustomGlob || AllGlobs.glob)
    WHERE NOT IsDir AND MaybeUpload(OSPath=OSPath)

parameters:
- name: MatchFilename
  description: |
    If set we use the filename to detect the type of sqlite file.
    When unset we use heristics (slower)
  type: bool
  default: Y

- name: CustomGlob
  description: Specify this glob to select other files

- name: DateAfter
  description: Timebox output to rows after this time.
  type: timestamp
  default: "1970-01-01T00:00:00Z"

- name: DateBefore
  description: Timebox output to rows after this time.
  type: timestamp
  default: "2100-01-01T00:00:00Z"

- name: FilterRegex
  description: Filter critical rows by this regex
  type: regex
  default: .


- name: All
  description: Select targets with category All
  type: bool
  default: Y


- name: MacOS
  description: Select targets with category MacOS
  type: bool
  default: N


- name: Chrome
  description: Select targets with category Chrome
  type: bool
  default: N


- name: Browser
  description: Select targets with category Browser
  type: bool
  default: N


- name: Edge
  description: Select targets with category Edge
  type: bool
  default: N


- name: Firefox
  description: Select targets with category Firefox
  type: bool
  default: N


- name: InternetExplorer
  description: Select targets with category InternetExplorer
  type: bool
  default: N


- name: Windows
  description: Select targets with category Windows
  type: bool
  default: N


- name: SQLITE_ALWAYS_MAKE_TEMPFILE
  type: bool
  default: Y

- name: AlsoUpload
  description: If specified we also upload the identified file.
  type: bool

sources:
- name: AllFiles
  query: |
    SELECT * FROM AllFiles


- name: iMessage_Profiles
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="iMessage_Profiles")
    SELECT timestamp(epoch=date / 1000000000 + 978307200) AS Timestamp, *
    FROM Rows
    WHERE Timestamp > DateAfter AND Timestamp < DateBefore
      AND (MessageText, RoomName) =~ FilterRegex
    


- name: Chromium Browser Autofill_Profiles
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Autofill_Profiles")
    SELECT GUID,
      timestamp(epoch= date_modified) AS DateModified,
      timestamp(epoch= use_date) AS UseDate,
      FirstName, MiddleName, LastName, EmailAddress,
      PhoneNumber, CompanyName, StreetAddress,
      City, State, ZipCode, UseCount, OSPath
    FROM Rows
    WHERE UseDate > DateAfter AND UseDate < DateBefore
      AND (FirstName, MiddleName, LastName, EmailAddress, CompanyName, StreetAddress) =~ FilterRegex
    


- name: Chromium Browser Autofill_Masked Credit Cards
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Autofill_Masked Credit Cards")
    SELECT * FROM Rows


- name: Chromium Browser Bookmarks
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Bookmarks")
    -- Recursive function to report the details of a folder
    LET ReportFolder(Data, BaseName) = SELECT * FROM chain(a={
      -- First row emit the data about the actual folder
      SELECT BaseName + " | " + Data.name AS Name,
             timestamp(winfiletime=int(int=Data.date_added) * 10) AS DateAdded,
             timestamp(winfiletime=int(int=Data.date_last_used) * 10) AS DateLastUsed,
             Data.type AS Type,
             Data.url || ""  AS URL
      FROM scope()
    },
    b={
       -- If this folder has children recurse into it
       SELECT * FROM foreach(row={
          SELECT _value FROM items(item=Data.children)
       },  query={
          SELECT * FROM ReportFolder(Data=_value, BaseName=BaseName + " | " + Data.name)
       })
    })
    
    LET MatchingFiles = SELECT OSPath, parse_json(data=read_file(filename=OSPath)) AS Data
    FROM Rows
    
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT * FROM chain(
      a={
        SELECT OSPath, *, "bookmark_bar" AS Type
        FROM ReportFolder(Data=Data.roots.bookmark_bar, BaseName="")
      },
      b={
        SELECT OSPath, *, "other" AS Type
        FROM ReportFolder(Data=Data.roots.other, BaseName="")
      },
      c={
        SELECT OSPath, *, "synced" AS Type
        FROM ReportFolder(Data=Data.roots.synced, BaseName="")
      })
    })
    


- name: Chromium Browser_Cookies
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser_Cookies")
    SELECT timestamp(winfiletime=(creation_utc * 10) || 0) AS CreationUTC,
           timestamp(winfiletime=(expires_utc * 10) || 0) AS ExpiresUTC,
           timestamp(winfiletime=(last_access_utc * 10) || 0) AS LastAccessUTC,
           HostKey, Name, Path,
           Bool(Value=is_secure) AS IsSecure,
           Bool(Value=is_httponly) AS IsHttpOnly,
           Bool(Value=has_expires) AS HasExpiration,
           Bool(Value=is_persistent) AS IsPersistent,
           Priority, SourcePort, OSPath
    FROM Rows
    WHERE LastAccessUTC > DateAfter AND LastAccessUTC < DateBefore
      AND (Name, Path) =~ FilterRegex
    


- name: Chromium Browser Extensions
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Extensions")
    -- Resolve the message string against the Locale dict
    LET ResolveName(Message, Locale) = get(item=Locale,
          field=lowcase(string=parse_string_with_regex(regex="^__MSG_(.+)__$", string=Message).g1),
          default=Message).message || Message
    
    -- Read the manifest files
    LET ManifestData = SELECT OSPath, parse_json(data=read_file(filename=OSPath)) AS Manifest
    FROM Rows
    
    -- Find the Locale file to help with.
    LET LocaleData = SELECT *, if(condition=Manifest.default_locale, else=dict(),
         then=parse_json(data=read_file(
            filename=OSPath.Dirname + "_locales" + Manifest.default_locale + "messages.json"))) AS Locale
    FROM ManifestData
    
    LET GetIcon(Manifest) = Manifest.icons.`128` || Manifest.icons.`64` || Manifest.icons.`32` || Manifest.icons.`16`
    
    SELECT OSPath, Manifest.author.email AS Email,
      ResolveName(Message = Manifest.name, Locale=Locale) AS name,
      ResolveName(Message = Manifest.description, Locale=Locale) AS description,
      Manifest.oauth2.scopes as Scopes,
      Manifest.permissions as Permissions,
      Manifest.key as Key, if(condition=GetIcon(Manifest=Manifest),
                then=upload(file=OSPath.Dirname + GetIcon(Manifest=Manifest))) AS Image,
      Manifest AS _Manifest
    FROM LocaleData
    WHERE (name, description) =~ FilterRegex
    


- name: Chromium Browser Favicons
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Favicons")
    SELECT ID, IconID,
      timestamp(winfiletime= (LastUpdated * 10) || 0) AS LastUpdated,
      PageURL, FaviconURL,
      upload(accessor="data",
         file=_image,
         name=format(format="Image%v.png", args=ID)) AS Image,
      OSPath as _OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
    


- name: Chromium Browser History_Visits
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Visits")
    SELECT ID,
       timestamp(winfiletime=(visit_time * 10) || 0) AS VisitTime,
       timestamp(winfiletime=(last_visit_time * 10) || 0) AS LastVisitedTime,
       URLTitle, URL, VisitCount, TypedCount,
       if(condition=hidden =~ '1', then="Yes", else="No") AS Hidden,
       VisitID, FromVisitID,
       visit_duration / 1000000 AS VisitDurationInSeconds,
       OSPath
    FROM Rows
    WHERE VisitTime > DateAfter
      AND VisitTime < DateBefore
      AND (URLTitle, URL) =~ FilterRegex
    


- name: Chromium Browser History_Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Downloads")
    LET StateLookup <= dict(`0`='In Progress', `1`='Complete', `2`="Cancelled", `3`="Interrupted", `4`="Interrupted")
    LET DangerType <= dict(`0`='Not Dangerous', `1`="Dangerous", `2`='Dangerous URL', `3`='Dangerous Content',
        `4`='Content May Be Malicious', `5`='Uncommon Content', `6`='Dangerous But User Validated',
        `7`='Dangerous Host', `8`='Potentially Unwanted', `9`='Whitelisted by Policy')
    LET InterruptReason <= dict(`0`= 'No Interrupt', `1`= 'File Error', `2`='Access Denied', `3`='Disk Full',
      `5`='Path Too Long',`6`='File Too Large', `7`='Virus', `10`='Temporary Problem', `11`='Blocked',
      `12`='Security Check Failed', `13`='Resume Error', `20`='Network Error', `21`='Operation Timed Out',
      `22`='Connection Lost', `23`='Server Down', `30`='Server Error', `31`='Range Request Error',
      `32`='Server Precondition Error', `33`='Unable to get file', `34`='Server Unauthorized',
      `35`='Server Certificate Problem', `36`='Server Access Forbidden', `37`='Server Unreachable',
      `38`='Content Length Mismatch', `39`='Cross Origin Redirect', `40`='Cancelled', `41`='Browser Shutdown',
      `50`='Browser Crashed')
    
    SELECT ID, GUID, CurrentPath, TargetPath, OriginalMIMEType, ReceivedBytes, TotalBytes,
      timestamp(winfiletime=(start_time * 10) || 0) AS StartTime,
      timestamp(winfiletime=(end_time * 10) || 0) AS EndTime,
      timestamp(winfiletime=(opened * 10) || 0) AS Opened,
      timestamp(winfiletime=(last_access_time * 10) || 0) AS LastAccessTime,
      timestamp(epoch=last_modified) AS LastModified,
      get(item=StateLookup, field=str(str=state), default="Unknown") AS State,
      get(item=DangerType, field=str(str=danger_type), default="Unknown") AS DangerType,
      get(item=InterruptReason, field=str(str=interrupt_reason), default="Unknown") AS InterruptReason,
      ReferrerURL, SiteURL, TabURL, TabReferrerURL, DownloadURL, OSPath
    FROM Rows
    WHERE LastAccessTime > DateAfter AND LastAccessTime < DateBefore
      AND (SiteURL, DownloadURL, TabURL, TabReferrerURL, ReferrerURL, DownloadURL) =~ FilterRegex
    


- name: Chromium Browser History_Keywords
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Keywords")
    SELECT KeywordID, URLID,
       timestamp(winfiletime=(last_visit_time * 10) || 0) AS LastVisitedTime,
       KeywordSearchTerm, Title, URL, OSPath
    FROM Rows
    WHERE LastVisitedTime > DateAfter AND LastVisitedTime < DateBefore
      AND (Title, KeywordSearchTerm, URL) =~ FilterRegex
    


- name: Chromium Browser Media_History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Media_History")
    SELECT ID, URL, WatchTimeSeconds,
       Bool(Value=has_video) AS HasVideo,
       Bool(Value=has_audio) AS HasAudio,
       timestamp(winfiletime=last_updated_time_s || 0) AS LastUpdated,
       OriginID, OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
      AND URL =~ FilterRegex
    


- name: Chromium Browser Media_Playback Session
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Media_Playback Session")
    SELECT ID,
      timestamp(winfiletime=last_updated_time_s || 0) AS LastUpdated, URL,
      duration_ms / 1000 AS DurationInSeconds,
      position_ms / 1000 AS PositionInSeconds,
      Title, Artist, Album, SourceTitle, OriginID, OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
      AND URL =~ FilterRegex
    


- name: Chromium Browser Network_Predictor
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Network_Predictor")
    SELECT * FROM Rows
    WHERE UserText =~ FilterRegex
    


- name: Chromium Browser Notifications_Site Engagements
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Notifications_Site Engagements")
    LET JSON = SELECT parse_json(data=read_file(filename=OSPath)) AS Data, OSPath FROM Rows
    
    SELECT * FROM foreach(row={
      SELECT OSPath, Data.profile.content_settings.exceptions AS exceptions FROM JSON
    },  query={
      SELECT _key AS Site,
         timestamp(winfiletime=int(int=_value.last_modified) * 10 || 0) AS LastModified,
         timestamp(winfiletime=int(int=_value.setting.lastEngagementTime) * 10 || 0) AS LastEngagementTime,
         OSPath
      FROM items(item=exceptions.site_engagement)
    })
    


- name: Chromium Browser Notifications_App Banners
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Notifications_App Banners")
    LET JSON = SELECT parse_json(data=read_file(filename=OSPath)) AS Data, OSPath FROM Rows
    
    SELECT * FROM foreach(row={
      SELECT OSPath, Data.profile.content_settings.exceptions AS exceptions FROM JSON
    },  query={
      SELECT _key AS Site,
         timestamp(winfiletime=int(int=_value.last_modified) * 10 || 0) AS LastModified,
         {
           SELECT _key AS Site,
              timestamp(winfiletime=int(int=_value.couldShowBannerEvents) * 10 || 0) AS CouldShowBannerEvents,
              timestamp(winfiletime=int(int=_value.next_install_text_animation.last_shown) * 10 || 0) AS LastShown
           FROM items(item=_value.setting)
         } AS Setting,
         OSPath
      FROM items(item=exceptions.app_banner)
    })
    


- name: Chromium Browser Notifications_Notification Preferences
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Notifications_Notification Preferences")
    LET ContentSettings <= array(`0`="Default",`1`="Allow",`2`="Block",`3`="Ask",`4`="Session Only",`5`="Detect Important Content")
    
    LET JSON = SELECT parse_json(data=read_file(filename=OSPath)) AS Data, OSPath FROM Rows
    
    SELECT * FROM foreach(row={
      SELECT OSPath, Data.profile.content_settings.exceptions AS exceptions FROM JSON
    },  query={
      SELECT _key AS Site,
        timestamp(winfiletime=int(int=_value.last_modified) * 10 || 0) AS LastModified,
        ContentSettings[_value.setting] AS Setting,
        OSPath
      FROM items(item=exceptions.notifications)
    })
    


- name: Chromium Browser Notifications_Notification Interactions
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Notifications_Notification Interactions")
    LET JSON = SELECT parse_json(data=read_file(filename=OSPath)) AS Data, OSPath FROM Rows
    LET S = scope()
    
    SELECT * FROM foreach(row={
      SELECT OSPath, Data.profile.content_settings.exceptions AS exceptions FROM JSON
    },  query={
      SELECT _key AS URL,
        timestamp(winfiletime=int(int=_value.last_modified) * 10 || 0) AS LastModified,
        _value.display_count as DisplayCount,
        _value.click_count as ClickCount,
        OSPath
      FROM items(item=S.notification_interactions || dict())
    })
    


- name: Chromium Browser Shortcuts
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Shortcuts")
    SELECT ID,
      timestamp(winfiletime= (last_access_time * 10) || 0) AS LastAccessTime,
      TextTyped, FillIntoEdit, URL, Contents,
      Description, Type, Keyword, TimesSelectedByUser, OSPath
    FROM Rows
    WHERE LastAccessTime > DateAfter AND LastAccessTime < DateBefore
      AND (Contents, Description) =~ FilterRegex
    


- name: Chromium Sessions_Sessions
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Sessions_Sessions")
    SELECT timestamp(winfiletime=(creation_utc * 10) || 0) AS CreationUTC,
           timestamp(winfiletime=(expires_utc * 10) || 0) AS ExpiresUTC,
           timestamp(winfiletime=(last_access_utc * 10) || 0) AS LastAccessUTC,
           HostKey, Name, Path,
           Bool(Value=is_secure) AS IsSecure,
           Bool(Value=is_httponly) AS IsHttpOnly,
           Bool(Value=has_expires) AS HasExpiration,
           Bool(Value=is_persistent) AS IsPersistent,
           Priority, SourcePort, OSPath
    FROM Rows
    WHERE LastAccessUTC > DateAfter AND LastAccessUTC < DateBefore
      AND (Name, Path) =~ FilterRegex
    


- name: Chromium Browser Top Sites
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Top Sites")
    SELECT * FROM Rows
    WHERE ( URL =~ FilterRegex OR Title =~ FilterRegex )
    


- name: Edge Browser Navigation History_Navigation History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Edge Browser Navigation History_Navigation History")
    SELECT ID,
       timestamp(epoch=`Last Visited Time`) AS `Last Visited Time`,
       Title, URL, VisitCount, OSPath
    FROM Rows
    WHERE `Last Visited Time` > DateAfter
      AND `Last Visited Time` < DateBefore
      AND (Title, URL) =~ FilterRegex
    


- name: Firefox Places
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places")
    LET BookmarkTypes <= dict(`1`="URL", `2`="Folder", `3`="Separator")
    SELECT ID, ParentID,
       get(item= BookmarkTypes, field=str(str=type), default="Unknown") AS Type,
       timestamp(epoch=dateAdded) AS DateAdded,
       timestamp(epoch=lastModified) AS LastModified,
       Position, Title, URL, ForeignKey, OSPath
    FROM Rows
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND (Title, URL) =~ FilterRegex
    


- name: Firefox Places_Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places_Downloads")
    SELECT PlaceID, Content,
       timestamp(epoch=dateAdded) AS DateAdded,
       timestamp(epoch=lastModified) AS LastModified,
       OSPath
    FROM Rows
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND Content =~ FilterRegex
    


- name: Firefox Places_History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places_History")
    LET VisitType <= dict(`1`='TRANSITION_LINK', `2`='TRANSITION_TYPED', `3`='TRANSITION_BOOKMARK',
      `4`='TRANSITION_EMBED', `5`= 'TRANSITION_REDIRECT_PERMANENT', `6`='TRANSITION_REDIRECT_TEMPORARY',
      `7`='TRANSITION_DOWNLOAD', `8`='TRANSITION_FRAMED_LINK', `9`='TRANSITION_RELOAD')
    
    SELECT VisitID, FromVisitID,
       timestamp(epoch= last_visit_date) AS LastVisitDate,
       VisitCount, URL, Title, Description,
       get(item= VisitType, field=str(str=visit_type), default="Unknown") AS VisitType,
       Bool(Value=hidden) AS Hidden,
       Bool(Value=typed) AS Typed,
       Frecency, PreviewImageURL, OSPath
    FROM Rows
    WHERE LastVisitDate > DateAfter AND LastVisitDate < DateBefore
      AND (Title, URL, Description) =~ FilterRegex
    


- name: Firefox Cookies
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Cookies")
    SELECT ID, Host, Name, Value,
       timestamp(epoch= creationTime) AS CreationTime,
       timestamp(epoch= lastAccessed) AS LastAccessedTime,
       timestamp(epoch= expiry) AS Expiration,
       Bool(Value= isSecure) AS IsSecure,
       Bool(Value= isHttpOnly) AS IsHTTPOnly, OSPath
    FROM Rows
    WHERE LastAccessedTime > DateAfter
      AND LastAccessedTime < DateBefore
      AND ( Name =~ FilterRegex OR Value =~ FilterRegex )
    


- name: Firefox Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Downloads")
    SELECT ID, Name, MIMEType, Source, Target,
       timestamp(epoch= startTime) AS StartTime,
       timestamp(epoch= endTime) AS EndTime,
       timestamp(epoch= expiry) AS Expiration,
       CurrentBytes, MaxBytes, OSPath
    FROM Rows
    WHERE StartTime > DateAfter
      AND StartTime < DateBefore
      AND Name =~ FilterRegex
    


- name: Firefox Favicons
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Favicons")
    SELECT ID, PageURL, FaviconURL,
       timestamp(epoch= expire_ms) AS Expiration,
       OSPath
    FROM Rows
    


- name: Firefox Form History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Form History")
    SELECT ID, FieldName, Value, TimesUsed,
       timestamp(epoch= firstUsed) AS FirstUsed,
       timestamp(epoch= lastUsed) AS LastUsed,
       GUID, OSPath
    FROM Rows
    WHERE LastUsed > DateAfter AND LastUsed < DateBefore
      AND ( FieldName =~ FilterRegex OR Value =~ FilterRegex )
    


- name: IE or Edge WebCacheV01_All Data
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="IE or Edge WebCacheV01_All Data")
    LET MatchingFiles = SELECT OSPath FROM Rows
    LET S = scope()
    
    LET Containers(OSPath) = SELECT Table
    FROM parse_ese_catalog(file=OSPath)
    WHERE Table =~ "Container_"
    GROUP BY Table
    
    LET AllHits(OSPath) = SELECT * FROM foreach(row={
        SELECT * FROM Containers(OSPath=OSPath)
    }, query={
       SELECT timestamp(winfiletime=ExpiryTime) AS ExpiryTime,
          timestamp(winfiletime=ModifiedTime) AS ModifiedTime,
          timestamp(winfiletime=AccessedTime) AS AccessedTime,
          S.Url AS Url, *
       FROM parse_ese(file=OSPath, table=Table)
    })
    
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT * FROM AllHits(OSPath=OSPath)
    })
    WHERE AccessedTime > DateAfter AND AccessedTime < DateBefore
      AND Url =~ FilterRegex
    


- name: IE or Edge WebCacheV01_Highlights
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="IE or Edge WebCacheV01_Highlights")
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT AccessedTime, ModifiedTime, ExpiryTime, Url
      FROM AllHits(OSPath=OSPath)
    })
    WHERE AccessedTime > DateAfter AND AccessedTime < DateBefore
      AND Url =~ FilterRegex
    


- name: MacOS Applications Cache
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS Applications Cache")
    SELECT
       time_stamp AS Timestamp,
       OSPath.Base AS Application,
       entry_ID AS EntryID,
       version AS Version,
       hash_value AS Hash,
       storage_policy AS StoragePolicy,
       request_key AS URL,
       plist(file=request_object, accessor="data") AS Request,
       plist(file=response_object, accessor="data") AS Response,
       partition AS Partition,
       OSPath
    FROM Rows
    WHERE Timestamp > DateAfter AND Timestamp < DateBefore
      AND Application =~ FilterRegex
    


- name: MacOS NetworkUsage
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS NetworkUsage")
    SELECT timestamp(epoch= ZTIMESTAMP + 978307200) AS Timestamp,
      timestamp(epoch= ZFIRSTTIMESTAMP + 978307200) AS FirstTimestamp,
      timestamp(epoch= LIVE_USAGE_TIMESTAMP + 978307200) AS LiveUsageTimestamp,
      ZBUNDLENAME AS BundleID,
      ZPROCNAME AS ProcessName,
      ZWIFIIN AS WifiIn,
      ZWIFIOUT AS WifiOut,
      ZWWANIN AS WanIn,
      ZWWANOUT AS WandOut,
      ZWIREDIN AS WiredIn,
      ZWIREDOUT AS WiredOut,
      ZXIN AS _XIn,
      ZXOUT AS _XOut,
      Z_PK AS LiveUsageTableID
    FROM Rows
    


- name: MacOS Notes
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS Notes")
    SELECT Key AS _Key,
     OSPath[1] AS User,
     Note,
     Title,
     Snippet,
     NoteID AS _NoteID,
     timestamp(cocoatime=CreatedTS) AS CreatedTime,
     timestamp(cocoatime=LastOpenedDate) AS LastOpenedTime,
     timestamp(cocoatime=DirModificationDate) AS LastDirModifcation,
     Account AS _Account,
     Directory,
     DirectoryID,
     AttachmentName,
     AttachmentSize,
     AttachmentUUID,
     if(condition=AttachmentUUID,
        then=OSPath[:2] + '/Library/Group Containers/group.com.apple.notes/Accounts/LocalAccount/Media/' + AttachmentUUID + '/' + AttachmentName) AS AttachmentLocation,
     AccountName AS _AccountName,
     AccountID AS _AccountID,
     AccountType AS _AccountType,
     gunzip(string=Data) AS Data,
     OSPath
    FROM Rows
    WHERE LastOpenedTime > DateAfter AND LastOpenedTime < DateBefore
      AND ( Title =~ FilterRegex OR Data =~ FilterRegex )
    


- name: MacOS XProtect Detections
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS XProtect Detections")
    SELECT *
    FROM Rows
    WHERE dt > DateAfter
      AND dt < DateBefore
      AND (violated_rule, exec_path, responsible_path, responsible_signing_id,
        exec_cdhash, exec_sha256, responsible_cdhash, responsible_sha256 ) =~ FilterRegex
    


- name: Windows Activities Cache_ActivityPackageId
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Windows Activities Cache_ActivityPackageId")
    SELECT format(format="%0X-%0X-%0X-%0X-%0X", args=[
      ActivityId[0:4], ActivityId[4:6], ActivityId[6:8],
      ActivityId[8:10], ActivityId[10:] ]) AS ActivityId,
      Platform, PackageName, ExpirationTime, OSPath
    FROM Rows
    


- name: Windows Activities Cache_Clipboard
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Windows Activities Cache_Clipboard")
    SELECT
      CreatedTime,
      timestamp(epoch=LastModifiedTime) AS LastModifiedTime,
      timestamp(epoch=LastModifiedOnClient) AS LastModifiedOnClient,
      StartTime,
      EndTime,
      Payload,
      OSPath[1] AS User,
      base64decode(string=parse_json_array(data=ClipboardPayload)[0].content) AS ClipboardPayload,
      OSPath AS Path,
      Mtime
    FROM Rows
    WHERE StartTime > DateAfter
      AND StartTime < DateBefore
      AND ClipboardPayload =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_Gthr
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_Gthr")
    LET MatchingFiles = SELECT OSPath FROM Rows
    
    LET FormatTimeB(T) = timestamp(winfiletime=parse_binary(
       filename=T, accessor="data", struct="uint64b"))
    
    LET FormatTime(T) = timestamp(winfiletime=parse_binary(
       filename=T, accessor="data", struct="uint64"))
    
    LET FormatSize(T) = parse_binary(
       filename=T, accessor="data", struct="uint64")
    
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT ScopeID, DocumentID, SDID,
          FormatTimeB(T=LastModified) AS LastModified,
          FileName
       FROM parse_ese(file=OSPath, table= "SystemIndex_Gthr")
    })
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND FileName =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_GthrPth
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_GthrPth")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT Scope, Parent, Name
       FROM parse_ese(file=OSPath, table= "SystemIndex_GthrPth")
    })
    WHERE Name =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_PropertyStore
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_PropertyStore")
    LET X = scope()
    
    -- The PropertyStore columns look like
    -- <random>-ProperName so we strip the
    -- random part off to display it properly.
    LET FilterDict(Dict) = to_dict(item={
      SELECT split(sep_string="-", string=_key)[1] || _key AS _key, _value
      FROM items(item=Dict)
    })
    
    LET PropStore(OSPath) = SELECT *,
       FormatTime(T=X.System_Search_GatherTime) AS System_Search_GatherTime,
       FormatSize(T=X.System_Size) AS System_Size,
       FormatTime(T=X.System_DateModified) AS System_DateModified,
       FormatTime(T=X.System_DateAccessed) AS System_DateAccessed,
       FormatTime(T=X.System_DateCreated) AS System_DateCreated
    FROM foreach(row={
       SELECT *, FilterDict(Dict=_value) AS _value
       FROM items(item={
         SELECT * FROM parse_ese(file=OSPath, table="SystemIndex_PropertyStore")
      })
    }, column="_value")
    
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT *
       FROM PropStore(OSPath=OSPath)
    })
    WHERE System_DateAccessed > DateAfter AND System_DateAccessed < DateBefore
    


- name: Windows Search Service_SystemIndex_PropertyStore_Highlights
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_PropertyStore_Highlights")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT WorkID,
          System_Search_GatherTime,
          System_Size,
          System_DateModified,
          System_DateCreated,
          X.System_FileOwner AS System_FileOwner,
          X.System_ItemPathDisplay AS System_ItemPathDisplay,
          X.System_ItemType AS System_ItemType,
          X.System_FileAttributes AS System_FileAttributes,
          X.System_Search_AutoSummary AS System_Search_AutoSummary
       FROM PropStore(OSPath=OSPath)
    })
    WHERE System_DateAccessed > DateAfter AND System_DateAccessed < DateBefore
    


- name: Windows Search Service_BrowsingActivity
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_BrowsingActivity")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT X.ItemPathDisplay AS ItemPathDisplay,
          X.Activity_ContentUri AS Activity_ContentUri,
          X.Activity_Description AS Activity_Description
       FROM PropStore(OSPath=OSPath)
       WHERE Activity_ContentUri
    })
    


- name: Windows Search Service_UserActivityLogging
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_UserActivityLogging")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT X.System_ItemPathDisplay AS System_ItemPathDisplay,
           FormatTime(T=X.ActivityHistory_StartTime) AS ActivityHistory_StartTime,
           FormatTime(T=X.ActivityHistory_EndTime) AS ActivityHistory_EndTime,
           X.ActivityHistory_AppId AS ActivityHistory_AppId
       FROM PropStore(OSPath=OSPath)
       WHERE ActivityHistory_AppId
    })
    WHERE ActivityHistory_StartTime > DateAfter
      AND ActivityHistory_StartTime < DateBefore
    



