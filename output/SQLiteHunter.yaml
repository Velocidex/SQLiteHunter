
name: Generic.Forensic.SQLiteHunter
description: |
    Hunt for SQLite files.
    
    SQLite has become the de-facto standard for storing application data,
    in many types of applications:
    
    - Web Browsers
    - Operating Systems
    - Various applications, such as iMessage, TCC etc
    
    This artifact can hunt for these artifacts in a mostly automated way.
    More info at https://github.com/Velocidex/SQLiteHunter
    
    NOTE: If you want to use this artifact on just a bunch of files already
    collected (for example the files collected using the
    Windows.KapeFiles.Targets artifact) you can use the CustomGlob parameter
    (for example set it to "/tmp/unpacked/**" to consider all files in the
    unpacked directory).
    
    

column_types:
- name: Image
  type: preview_upload

export: |
  LET SPEC <= "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"
  LET Specs <= parse_json(data=gunzip(string=base64decode(string=SPEC)))
  LET CheckHeader(OSPath) = read_file(filename=OSPath, length=12) = "SQLite forma"
  LET Bool(Value) = if(condition=Value, then="Yes", else="No")

  -- In fast mode we check the filename, then the header then run the sqlite precondition
  LET matchFilename(SourceName, OSPath) = OSPath =~ get(item=Specs.sources, field=SourceName).filename
    AND CheckHeader(OSPath=OSPath)
    AND Identify(SourceName= SourceName, OSPath= OSPath)
    AND log(message=format(format="%v matched by filename %v",
            args=[OSPath, get(item=Specs.sources, field=SourceName).filename]))

  -- If the user wanted to also upload the file, do so now
  LET MaybeUpload(OSPath) = if(condition=AlsoUpload, then=upload(file=OSPath)) OR TRUE

  LET Identify(SourceName, OSPath) = SELECT if(
    condition=CheckHeader(OSPath=OSPath),
    then={
      SELECT *
      FROM sqlite(file=OSPath, query=get(item=Specs.sources, field=SourceName).id_query)
    }) AS Hits
  FROM scope()
  WHERE if(condition=Hits[0].Check = get(item=Specs.sources, field=SourceName).id_value,
    then= log(message="%v was identified as %v",
            args=[OSPath, get(item=Specs.sources, field=SourceName).Name]),
    else=log(message="%v was not identified as %v (got %v, wanted %v)",
             args=[OSPath, get(item=Specs.sources, field=SourceName).Name, str(str=Hits),
                   get(item=Specs.sources, field=SourceName).id_value]) AND FALSE)

  LET ApplyFile(SourceName) = SELECT * FROM foreach(row={
     SELECT OSPath FROM AllFiles
     WHERE if(condition=MatchFilename,  then=matchFilename(SourceName=SourceName, OSPath=OSPath),
      else=Identify(SourceName= SourceName, OSPath= OSPath))

  }, query={
     SELECT *, OSPath FROM sqlite(
        file=OSPath, query=get(item=Specs.sources, field=SourceName).SQL)
  })

  -- Filter for matching files without sqlite checks.
  LET FilterFile(SourceName) =
     SELECT OSPath FROM AllFiles
     WHERE if(condition=MatchFilename,
              then=OSPath =~ get(item=Specs.sources, field=SourceName).filename)

  -- Build a regex for all enabled categories.
  LET all_categories = SELECT _value FROM foreach(row=["All","MacOS","Chrome","Browser","Edge","Firefox","InternetExplorer","Windows"]) WHERE get(field=_value)
  LET category_regex <= join(sep="|", array=all_categories._value)
  LET AllGlobs <= filter(list=Specs.globs, condition="x=> x.tags =~ category_regex")
  LET _ <= log(message="Globs for category %v is %v", args=[category_regex, CustomGlob || AllGlobs.glob])
  LET AllFiles <= SELECT OSPath FROM glob(globs=CustomGlob || AllGlobs.glob)
    WHERE NOT IsDir AND MaybeUpload(OSPath=OSPath)

parameters:
- name: MatchFilename
  description: |
    If set we use the filename to detect the type of sqlite file.
    When unset we use heristics (slower)
  type: bool
  default: Y

- name: CustomGlob
  description: Specify this glob to select other files

- name: DateAfter
  description: Timebox output to rows after this time.
  type: timestamp
  default: "1970-01-01T00:00:00Z"

- name: DateBefore
  description: Timebox output to rows after this time.
  type: timestamp
  default: "2100-01-01T00:00:00Z"

- name: FilterRegex
  description: Filter critical rows by this regex
  type: regex
  default: .


- name: All
  description: Select targets with category All
  type: bool
  default: Y


- name: MacOS
  description: Select targets with category MacOS
  type: bool
  default: N


- name: Chrome
  description: Select targets with category Chrome
  type: bool
  default: N


- name: Browser
  description: Select targets with category Browser
  type: bool
  default: N


- name: Edge
  description: Select targets with category Edge
  type: bool
  default: N


- name: Firefox
  description: Select targets with category Firefox
  type: bool
  default: N


- name: InternetExplorer
  description: Select targets with category InternetExplorer
  type: bool
  default: N


- name: Windows
  description: Select targets with category Windows
  type: bool
  default: N


- name: SQLITE_ALWAYS_MAKE_TEMPFILE
  type: bool
  default: Y

- name: AlsoUpload
  description: If specified we also upload the identified file.
  type: bool

sources:
- name: AllFiles
  query: |
    SELECT * FROM AllFiles


- name: iMessage_Profiles
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="iMessage_Profiles")
    SELECT timestamp(epoch=date / 1000000000 + 978307200) AS Timestamp, *
    FROM Rows
    WHERE Timestamp > DateAfter AND Timestamp < DateBefore
      AND (MessageText, RoomName) =~ FilterRegex
    


- name: Chromium Browser Autofill_Profiles
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Autofill_Profiles")
    SELECT GUID,
      timestamp(epoch= date_modified) AS DateModified,
      timestamp(epoch= use_date) AS UseDate,
      FirstName, MiddleName, LastName, EmailAddress,
      PhoneNumber, CompanyName, StreetAddress,
      City, State, ZipCode, UseCount, OSPath
    FROM Rows
    WHERE UseDate > DateAfter AND UseDate < DateBefore
      AND (FirstName, MiddleName, LastName, EmailAddress, CompanyName, StreetAddress) =~ FilterRegex
    


- name: Chromium Browser Autofill_Masked Credit Cards
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Autofill_Masked Credit Cards")
    SELECT * FROM Rows


- name: Chromium Browser Bookmarks
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Bookmarks")
    -- Recursive function to report the details of a folder
    LET ReportFolder(Data, BaseName) = SELECT * FROM chain(a={
      -- First row emit the data about the actual folder
      SELECT BaseName + " | " + Data.name AS Name,
             timestamp(winfiletime=int(int=Data.date_added) * 10) AS DateAdded,
             timestamp(winfiletime=int(int=Data.date_last_used) * 10) AS DateLastUsed,
             Data.type AS Type,
             Data.url || ""  AS URL
      FROM scope()
    },
    b={
       -- If this folder has children recurse into it
       SELECT * FROM foreach(row={
          SELECT _value FROM items(item=Data.children)
       },  query={
          SELECT * FROM ReportFolder(Data=_value, BaseName=BaseName + " | " + Data.name)
       })
    })
    
    LET MatchingFiles = SELECT OSPath, parse_json(data=read_file(filename=OSPath)) AS Data
    FROM Rows
    
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT * FROM chain(
      a={
        SELECT OSPath, *, "bookmark_bar" AS Type
        FROM ReportFolder(Data=Data.roots.bookmark_bar, BaseName="")
      },
      b={
        SELECT OSPath, *, "other" AS Type
        FROM ReportFolder(Data=Data.roots.other, BaseName="")
      },
      c={
        SELECT OSPath, *, "synced" AS Type
        FROM ReportFolder(Data=Data.roots.synced, BaseName="")
      })
    })
    


- name: Chromium Browser_Cookies
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser_Cookies")
    SELECT timestamp(winfiletime=(creation_utc * 10) || 0) AS CreationUTC,
           timestamp(winfiletime=(expires_utc * 10) || 0) AS ExpiresUTC,
           timestamp(winfiletime=(last_access_utc * 10) || 0) AS LastAccessUTC,
           HostKey, Name, Path,
           Bool(Value=is_secure) AS IsSecure,
           Bool(Value=is_httponly) AS IsHttpOnly,
           Bool(Value=has_expires) AS HasExpiration,
           Bool(Value=is_persistent) AS IsPersistent,
           Priority, SourcePort, OSPath
    FROM Rows
    WHERE LastAccessUTC > DateAfter AND LastAccessUTC < DateBefore
      AND (Name, Path) =~ FilterRegex
    


- name: Chromium Browser Extensions
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Chromium Browser Extensions")
    -- Resolve the message string against the Locale dict
    LET ResolveName(Message, Locale) = get(item=Locale,
          field=lowcase(string=parse_string_with_regex(regex="^__MSG_(.+)__$", string=Message).g1),
          default=Message).message || Message
    
    -- Read the manifest files
    LET ManifestData = SELECT OSPath, parse_json(data=read_file(filename=OSPath)) AS Manifest
    FROM Rows
    
    -- Find the Locale file to help with.
    LET LocaleData = SELECT *, if(condition=Manifest.default_locale, else=dict(),
         then=parse_json(data=read_file(
            filename=OSPath.Dirname + "_locales" + Manifest.default_locale + "messages.json"))) AS Locale
    FROM ManifestData
    
    LET GetIcon(Manifest) = Manifest.icons.`128` || Manifest.icons.`64` || Manifest.icons.`32` || Manifest.icons.`16`
    
    SELECT OSPath, Manifest.author.email AS Email,
      ResolveName(Message = Manifest.name, Locale=Locale) AS name,
      ResolveName(Message = Manifest.description, Locale=Locale) AS description,
      Manifest.oauth2.scopes as Scopes,
      Manifest.permissions as Permissions,
      Manifest.key as Key, if(condition=GetIcon(Manifest=Manifest),
                then=upload(file=OSPath.Dirname + GetIcon(Manifest=Manifest))) AS Image,
      Manifest AS _Manifest
    FROM LocaleData
    WHERE (name, description) =~ FilterRegex
    


- name: Chromium Browser Favicons
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Favicons")
    SELECT ID, IconID,
      timestamp(winfiletime= (LastUpdated * 10) || 0) AS LastUpdated,
      PageURL, FaviconURL,
      upload(accessor="data",
         file=_image,
         name=format(format="Image%v.png", args=ID)) AS Image,
      OSPath as _OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
    


- name: Chromium Browser History_Visits
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Visits")
    SELECT ID,
       timestamp(winfiletime=(visit_time * 10) || 0) AS VisitTime,
       timestamp(winfiletime=(last_visit_time * 10) || 0) AS LastVisitedTime,
       URLTitle, URL, VisitCount, TypedCount,
       if(condition=hidden =~ '1', then="Yes", else="No") AS Hidden,
       VisitID, FromVisitID,
       visit_duration / 1000000 AS VisitDurationInSeconds,
       OSPath
    FROM Rows
    WHERE VisitTime > DateAfter
      AND VisitTime < DateBefore
      AND (URLTitle, URL) =~ FilterRegex
    


- name: Chromium Browser History_Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Downloads")
    LET StateLookup <= dict(`0`='In Progress', `1`='Complete', `2`="Cancelled", `3`="Interrupted", `4`="Interrupted")
    LET DangerType <= dict(`0`='Not Dangerous', `1`="Dangerous", `2`='Dangerous URL', `3`='Dangerous Content',
        `4`='Content May Be Malicious', `5`='Uncommon Content', `6`='Dangerous But User Validated',
        `7`='Dangerous Host', `8`='Potentially Unwanted', `9`='Whitelisted by Policy')
    LET InterruptReason <= dict(`0`= 'No Interrupt', `1`= 'File Error', `2`='Access Denied', `3`='Disk Full',
      `5`='Path Too Long',`6`='File Too Large', `7`='Virus', `10`='Temporary Problem', `11`='Blocked',
      `12`='Security Check Failed', `13`='Resume Error', `20`='Network Error', `21`='Operation Timed Out',
      `22`='Connection Lost', `23`='Server Down', `30`='Server Error', `31`='Range Request Error',
      `32`='Server Precondition Error', `33`='Unable to get file', `34`='Server Unauthorized',
      `35`='Server Certificate Problem', `36`='Server Access Forbidden', `37`='Server Unreachable',
      `38`='Content Length Mismatch', `39`='Cross Origin Redirect', `40`='Cancelled', `41`='Browser Shutdown',
      `50`='Browser Crashed')
    
    SELECT ID, GUID, CurrentPath, TargetPath, OriginalMIMEType, ReceivedBytes, TotalBytes,
      timestamp(winfiletime=(start_time * 10) || 0) AS StartTime,
      timestamp(winfiletime=(end_time * 10) || 0) AS EndTime,
      timestamp(winfiletime=(opened * 10) || 0) AS Opened,
      timestamp(winfiletime=(last_access_time * 10) || 0) AS LastAccessTime,
      timestamp(epoch=last_modified) AS LastModified,
      get(item=StateLookup, field=str(str=state), default="Unknown") AS State,
      get(item=DangerType, field=str(str=danger_type), default="Unknown") AS DangerType,
      get(item=InterruptReason, field=str(str=interrupt_reason), default="Unknown") AS InterruptReason,
      ReferrerURL, SiteURL, TabURL, TabReferrerURL, DownloadURL, OSPath
    FROM Rows
    WHERE LastAccessTime > DateAfter AND LastAccessTime < DateBefore
      AND (SiteURL, DownloadURL, TabURL, TabReferrerURL, ReferrerURL, DownloadURL) =~ FilterRegex
    


- name: Chromium Browser History_Keywords
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser History_Keywords")
    SELECT KeywordID, URLID,
       timestamp(winfiletime=(last_visit_time * 10) || 0) AS LastVisitedTime,
       KeywordSearchTerm, Title, URL, OSPath
    FROM Rows
    WHERE LastVisitedTime > DateAfter AND LastVisitedTime < DateBefore
      AND (Title, KeywordSearchTerm, URL) =~ FilterRegex
    


- name: Chromium Browser Media_History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Media_History")
    SELECT ID, URL, WatchTimeSeconds,
       Bool(Value=has_video) AS HasVideo,
       Bool(Value=has_audio) AS HasAudio,
       timestamp(winfiletime=last_updated_time_s || 0) AS LastUpdated,
       OriginID, OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
      AND URL =~ FilterRegex
    


- name: Chromium Browser Media_Playback Session
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Media_Playback Session")
    SELECT ID,
      timestamp(winfiletime=last_updated_time_s || 0) AS LastUpdated, URL,
      duration_ms / 1000 AS DurationInSeconds,
      position_ms / 1000 AS PositionInSeconds,
      Title, Artist, Album, SourceTitle, OriginID, OSPath
    FROM Rows
    WHERE LastUpdated > DateAfter AND LastUpdated < DateBefore
      AND URL =~ FilterRegex
    


- name: Chromium Browser Network_Predictor
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Network_Predictor")
    SELECT * FROM Rows
    WHERE UserText =~ FilterRegex
    


- name: Chromium Browser Shortcuts
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Shortcuts")
    SELECT ID,
      timestamp(winfiletime= (last_access_time * 10) || 0) AS LastAccessTime,
      TextTyped, FillIntoEdit, URL, Contents,
      Description, Type, Keyword, TimesSelectedByUser, OSPath
    FROM Rows
    WHERE LastAccessTime > DateAfter AND LastAccessTime < DateBefore
      AND (Contents, Description) =~ FilterRegex
    


- name: Chromium Sessions_Sessions
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Sessions_Sessions")
    SELECT timestamp(winfiletime=(creation_utc * 10) || 0) AS CreationUTC,
           timestamp(winfiletime=(expires_utc * 10) || 0) AS ExpiresUTC,
           timestamp(winfiletime=(last_access_utc * 10) || 0) AS LastAccessUTC,
           HostKey, Name, Path,
           Bool(Value=is_secure) AS IsSecure,
           Bool(Value=is_httponly) AS IsHttpOnly,
           Bool(Value=has_expires) AS HasExpiration,
           Bool(Value=is_persistent) AS IsPersistent,
           Priority, SourcePort, OSPath
    FROM Rows
    WHERE LastAccessUTC > DateAfter AND LastAccessUTC < DateBefore
      AND (Name, Path) =~ FilterRegex
    


- name: Chromium Browser Top Sites
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Chromium Browser Top Sites")
    SELECT * FROM Rows
    WHERE ( URL =~ FilterRegex OR Title =~ FilterRegex )
    


- name: Edge Browser Navigation History_Navigation History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Edge Browser Navigation History_Navigation History")
    SELECT ID,
       timestamp(epoch=`Last Visited Time`) AS `Last Visited Time`,
       Title, URL, VisitCount, OSPath
    FROM Rows
    WHERE `Last Visited Time` > DateAfter
      AND `Last Visited Time` < DateBefore
      AND (Title, URL) =~ FilterRegex
    


- name: Firefox Places
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places")
    LET BookmarkTypes <= dict(`1`="URL", `2`="Folder", `3`="Separator")
    SELECT ID, ParentID,
       get(item= BookmarkTypes, field=str(str=type), default="Unknown") AS Type,
       timestamp(epoch=dateAdded) AS DateAdded,
       timestamp(epoch=lastModified) AS LastModified,
       Position, Title, URL, ForeignKey, OSPath
    FROM Rows
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND (Title, URL) =~ FilterRegex
    


- name: Firefox Places_Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places_Downloads")
    SELECT PlaceID, Content,
       timestamp(epoch=dateAdded) AS DateAdded,
       timestamp(epoch=lastModified) AS LastModified,
       OSPath
    FROM Rows
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND Content =~ FilterRegex
    


- name: Firefox Places_History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Places_History")
    LET VisitType <= dict(`1`='TRANSITION_LINK', `2`='TRANSITION_TYPED', `3`='TRANSITION_BOOKMARK',
      `4`='TRANSITION_EMBED', `5`= 'TRANSITION_REDIRECT_PERMANENT', `6`='TRANSITION_REDIRECT_TEMPORARY',
      `7`='TRANSITION_DOWNLOAD', `8`='TRANSITION_FRAMED_LINK', `9`='TRANSITION_RELOAD')
    
    SELECT VisitID, FromVisitID,
       timestamp(epoch= last_visit_date) AS LastVisitDate,
       VisitCount, URL, Title, Description,
       get(item= VisitType, field=str(str=visit_type), default="Unknown") AS VisitType,
       Bool(Value=hidden) AS Hidden,
       Bool(Value=typed) AS Typed,
       Frecency, PreviewImageURL, OSPath
    FROM Rows
    WHERE LastVisitDate > DateAfter AND LastVisitDate < DateBefore
      AND (Title, URL, Description) =~ FilterRegex
    


- name: Firefox Cookies
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Cookies")
    SELECT ID, Host, Name, Value,
       timestamp(epoch= creationTime) AS CreationTime,
       timestamp(epoch= lastAccessed) AS LastAccessedTime,
       timestamp(epoch= expiry) AS Expiration,
       Bool(Value= isSecure) AS IsSecure,
       Bool(Value= isHttpOnly) AS IsHTTPOnly, OSPath
    FROM Rows
    WHERE LastAccessedTime > DateAfter
      AND LastAccessedTime < DateBefore
      AND ( Name =~ FilterRegex OR Value =~ FilterRegex )
    


- name: Firefox Downloads
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Downloads")
    SELECT ID, Name, MIMEType, Source, Target,
       timestamp(epoch= startTime) AS StartTime,
       timestamp(epoch= endTime) AS EndTime,
       timestamp(epoch= expiry) AS Expiration,
       CurrentBytes, MaxBytes, OSPath
    FROM Rows
    WHERE StartTime > DateAfter
      AND StartTime < DateBefore
      AND Name =~ FilterRegex
    


- name: Firefox Favicons
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Favicons")
    SELECT ID, PageURL, FaviconURL,
       timestamp(epoch= expire_ms) AS Expiration,
       OSPath
    FROM Rows
    


- name: Firefox Form History
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Firefox Form History")
    SELECT ID, FieldName, Value, TimesUsed,
       timestamp(epoch= firstUsed) AS FirstUsed,
       timestamp(epoch= lastUsed) AS LastUsed,
       GUID, OSPath
    FROM Rows
    WHERE LastUsed > DateAfter AND LastUsed < DateBefore
      AND ( FieldName =~ FilterRegex OR Value =~ FilterRegex )
    


- name: IE or Edge WebCacheV01_All Data
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="IE or Edge WebCacheV01_All Data")
    LET MatchingFiles = SELECT OSPath FROM Rows
    
    LET Containers(OSPath) = SELECT Table
    FROM parse_ese_catalog(file=OSPath)
    WHERE Table =~ "Container_"
    GROUP BY Table
    
    LET AllHits(OSPath) = SELECT * FROM foreach(row={
        SELECT * FROM Containers(OSPath=OSPath)
    }, query={
       SELECT timestamp(winfiletime=ExpiryTime) AS ExpiryTime,
          timestamp(winfiletime=ModifiedTime) AS ModifiedTime,
          timestamp(winfiletime=AccessedTime) AS AccessedTime, Url, *
       FROM parse_ese(file=OSPath, table=Table)
    })
    
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT * FROM AllHits(OSPath=OSPath)
    })
    WHERE AccessedTime > DateAfter AND AccessedTime < DateBefore
      AND Url =~ FilterRegex
    


- name: IE or Edge WebCacheV01_Highlights
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="IE or Edge WebCacheV01_Highlights")
    SELECT * FROM foreach(row=MatchingFiles, query={
      SELECT AccessedTime, ModifiedTime, ExpiryTime, Url
      FROM AllHits(OSPath=OSPath)
    })
    WHERE AccessedTime > DateAfter AND AccessedTime < DateBefore
      AND Url =~ FilterRegex
    


- name: MacOS Applications Cache
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS Applications Cache")
    SELECT
       time_stamp AS Timestamp,
       OSPath.Base AS Application,
       entry_ID AS EntryID,
       version AS Version,
       hash_value AS Hash,
       storage_policy AS StoragePolicy,
       request_key AS URL,
       plist(file=request_object, accessor="data") AS Request,
       plist(file=response_object, accessor="data") AS Response,
       partition AS Partition,
       OSPath
    FROM Rows
    WHERE Timestamp > DateAfter AND Timestamp < DateBefore
      AND Application =~ FilterRegex
    


- name: MacOS NetworkUsage
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS NetworkUsage")
    SELECT timestamp(epoch= ZTIMESTAMP + 978307200) AS Timestamp,
      timestamp(epoch= ZFIRSTTIMESTAMP + 978307200) AS FirstTimestamp,
      timestamp(epoch= LIVE_USAGE_TIMESTAMP + 978307200) AS LiveUsageTimestamp,
      ZBUNDLENAME AS BundleID,
      ZPROCNAME AS ProcessName,
      ZWIFIIN AS WifiIn,
      ZWIFIOUT AS WifiOut,
      ZWWANIN AS WanIn,
      ZWWANOUT AS WandOut,
      ZWIREDIN AS WiredIn,
      ZWIREDOUT AS WiredOut,
      ZXIN AS _XIn,
      ZXOUT AS _XOut,
      Z_PK AS LiveUsageTableID
    FROM Rows
    


- name: MacOS Notes
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="MacOS Notes")
    SELECT Key AS _Key,
     OSPath[1] AS User,
     Note,
     Title,
     Snippet,
     NoteID AS _NoteID,
     timestamp(cocoatime=CreatedTS) AS CreatedTime,
     timestamp(cocoatime=LastOpenedDate) AS LastOpenedTime,
     timestamp(cocoatime=DirModificationDate) AS LastDirModifcation,
     Account AS _Account,
     Directory,
     DirectoryID,
     AttachmentName,
     AttachmentSize,
     AttachmentUUID,
     if(condition=AttachmentUUID,
        then=OSPath[:2] + '/Library/Group Containers/group.com.apple.notes/Accounts/LocalAccount/Media/' + AttachmentUUID + '/' + AttachmentName) AS AttachmentLocation,
     AccountName AS _AccountName,
     AccountID AS _AccountID,
     AccountType AS _AccountType,
     gunzip(string=Data) AS Data,
     OSPath
    FROM Rows
    WHERE LastOpenedTime > DateAfter AND LastOpenedTime < DateBefore
      AND ( Title =~ FilterRegex OR Data =~ FilterRegex )
    


- name: Windows Activities Cache_ActivityPackageId
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Windows Activities Cache_ActivityPackageId")
    SELECT format(format="%0X-%0X-%0X-%0X-%0X", args=[
      ActivityId[0:4], ActivityId[4:6], ActivityId[6:8],
      ActivityId[8:10], ActivityId[10:] ]) AS ActivityId,
      Platform, PackageName, ExpirationTime, OSPath
    FROM Rows
    


- name: Windows Activities Cache_Clipboard
  query: |
    LET Rows = SELECT * FROM ApplyFile(SourceName="Windows Activities Cache_Clipboard")
    SELECT
      CreatedTime,
      timestamp(epoch=LastModifiedTime) AS LastModifiedTime,
      timestamp(epoch=LastModifiedOnClient) AS LastModifiedOnClient,
      StartTime,
      EndTime,
      Payload,
      OSPath[1] AS User,
      base64decode(string=parse_json_array(data=ClipboardPayload)[0].content) AS ClipboardPayload,
      OSPath AS Path,
      Mtime
    FROM Rows
    WHERE StartTime > DateAfter
      AND StartTime < DateBefore
      AND ClipboardPayload =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_Gthr
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_Gthr")
    LET MatchingFiles = SELECT OSPath FROM Rows
    
    LET FormatTimeB(T) = timestamp(winfiletime=parse_binary(
       filename=T, accessor="data", struct="uint64b"))
    
    LET FormatTime(T) = timestamp(winfiletime=parse_binary(
       filename=T, accessor="data", struct="uint64"))
    
    LET FormatSize(T) = parse_binary(
       filename=T, accessor="data", struct="uint64")
    
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT ScopeID, DocumentID, SDID,
          FormatTimeB(T=LastModified) AS LastModified,
          FileName
       FROM parse_ese(file=OSPath, table= "SystemIndex_Gthr")
    })
    WHERE LastModified > DateAfter AND LastModified < DateBefore
      AND FileName =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_GthrPth
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_GthrPth")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT Scope, Parent, Name
       FROM parse_ese(file=OSPath, table= "SystemIndex_GthrPth")
    })
    WHERE Name =~ FilterRegex
    


- name: Windows Search Service_SystemIndex_PropertyStore
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_PropertyStore")
    LET X = scope()
    
    -- The PropertyStore columns look like
    -- <random>-ProperName so we strip the
    -- random part off to display it properly.
    LET FilterDict(Dict) = to_dict(item={
      SELECT split(sep_string="-", string=_key)[1] || _key AS _key, _value
      FROM items(item=Dict)
    })
    
    LET PropStore(OSPath) = SELECT *,
       FormatTime(T=X.System_Search_GatherTime) AS System_Search_GatherTime,
       FormatSize(T=X.System_Size) AS System_Size,
       FormatTime(T=X.System_DateModified) AS System_DateModified,
       FormatTime(T=X.System_DateAccessed) AS System_DateAccessed,
       FormatTime(T=X.System_DateCreated) AS System_DateCreated
    FROM foreach(row={
       SELECT *, FilterDict(Dict=_value) AS _value
       FROM items(item={
         SELECT * FROM parse_ese(file=OSPath, table="SystemIndex_PropertyStore")
      })
    }, column="_value")
    
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT *
       FROM PropStore(OSPath=OSPath)
    })
    WHERE System_DateAccessed > DateAfter AND System_DateAccessed < DateBefore
    


- name: Windows Search Service_SystemIndex_PropertyStore_Highlights
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_SystemIndex_PropertyStore_Highlights")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT WorkID,
          System_Search_GatherTime,
          System_Size,
          System_DateModified,
          System_DateCreated,
          X.System_FileOwner AS System_FileOwner,
          X.System_ItemPathDisplay AS System_ItemPathDisplay,
          X.System_ItemType AS System_ItemType,
          X.System_FileAttributes AS System_FileAttributes,
          X.System_Search_AutoSummary AS System_Search_AutoSummary
       FROM PropStore(OSPath=OSPath)
    })
    WHERE System_DateAccessed > DateAfter AND System_DateAccessed < DateBefore
    


- name: Windows Search Service_BrowsingActivity
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_BrowsingActivity")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT X.ItemPathDisplay AS ItemPathDisplay,
          X.Activity_ContentUri AS Activity_ContentUri,
          X.Activity_Description AS Activity_Description
       FROM PropStore(OSPath=OSPath)
       WHERE Activity_ContentUri
    })
    


- name: Windows Search Service_UserActivityLogging
  query: |
    LET Rows = SELECT * FROM FilterFile(SourceName="Windows Search Service_UserActivityLogging")
    SELECT * FROM foreach(row=MatchingFiles, query={
       SELECT X.System_ItemPathDisplay AS System_ItemPathDisplay,
           FormatTime(T=X.ActivityHistory_StartTime) AS ActivityHistory_StartTime,
           FormatTime(T=X.ActivityHistory_EndTime) AS ActivityHistory_EndTime,
           X.ActivityHistory_AppId AS ActivityHistory_AppId
       FROM PropStore(OSPath=OSPath)
       WHERE ActivityHistory_AppId
    })
    WHERE ActivityHistory_StartTime > DateAfter
      AND ActivityHistory_StartTime < DateBefore
    



